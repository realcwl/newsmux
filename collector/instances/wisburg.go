package collector_instances

import (
	"encoding/json"
	"errors"
	"fmt"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/Luismorlan/newsmux/collector"
	"github.com/Luismorlan/newsmux/collector/sink"
	"github.com/Luismorlan/newsmux/collector/working_context"
	"github.com/Luismorlan/newsmux/protocol"
	"github.com/Luismorlan/newsmux/utils"
	Logger "github.com/Luismorlan/newsmux/utils/log"
	"github.com/PuerkitoBio/goquery"
	"github.com/sirupsen/logrus"
	"google.golang.org/protobuf/types/known/timestamppb"
)

const (
	WisburgTimeFormat = "2006-01-02 15:04:05"
	WisburgBaseUrl    = "https://wisburg.com/"
)

type UnifiedWisburgPost struct {
	ID                 int           `json:"id"`
	Title              string        `json:"title"`
	TitleEn            string        `json:"title_en"`
	BodySummary        string        `json:"body_summary"`
	BodySummaryEn      string        `json:"body_summary_en"`
	Language           string        `json:"language"`
	CoverURI           string        `json:"cover_uri"`
	CoverSlideUris     []string      `json:"cover_slide_uris"`
	AuthorID           int           `json:"author_id"`
	PublisherID        int           `json:"publisher_id"`
	DisplayTime        string        `json:"display_time"`
	SourceURI          string        `json:"source_uri"`
	SourceURIExtension string        `json:"source_uri_extension"`
	SourceURIMime      string        `json:"source_uri_mime"`
	SourceName         string        `json:"source_name"`
	AthenaArticleID    int           `json:"athena_article_id"`
	IsFeatured         bool          `json:"is_featured"`
	IsFeaturedArchived bool          `json:"is_featured_archived"`
	FreeExpiredAt      time.Time     `json:"free_expired_at"`
	PageViews          int           `json:"page_views"`
	Tags               []interface{} `json:"tags"`
	WordsCount         int           `json:"words_count"`
	URI                string        `json:"uri"`
	Status             string        `json:"status"`
	IsAutoGenerated    bool          `json:"is_auto_generated"`
	IsTranslation      bool          `json:"is_translation"`
	DirtyWords         string        `json:"dirty_words"`
	HasDirtyWord       bool          `json:"has_dirty_word"`
	TranslateModel     string        `json:"translate_model"`
	Platform           string        `json:"platform"`
	IsFront            bool          `json:"is_front"`
	PlannedPublishAt   interface{}   `json:"planned_publish_at"`
	ArticleType        string        `json:"article_type"`
	TopicID            int           `json:"topic_id"`
	Topic              interface{}   `json:"topic"`
	TweetTemplate      string        `json:"tweet_template"`
	TweetTemplateEn    string        `json:"tweet_template_en"`
	TweetVars          []struct {
		URI  string `json:"uri"`
		Text string `json:"text"`
	} `json:"tweet_vars"`
	TweetVarsEn   []interface{} `json:"tweet_vars_en"`
	IsCooperation bool          `json:"is_cooperation"`
	VipVisibility int           `json:"vip_visibility"`
	FreeAt        interface{}   `json:"free_at"`
	Themes        []interface{} `json:"themes"`
	Author        struct {
		ID              int         `json:"id"`
		Nickname        string      `json:"nickname"`
		Signature       string      `json:"signature"`
		Sex             int         `json:"sex"`
		Avatar          string      `json:"avatar"`
		Status          string      `json:"status"`
		SubscriberCount int         `json:"subscriber_count"`
		IsWechatBound   bool        `json:"is_wechat_bound"`
		Occupation      string      `json:"occupation"`
		Industry        string      `json:"industry"`
		VerifyName      string      `json:"verify_name"`
		FollowerCount   int         `json:"follower_count"`
		FolloweeCount   int         `json:"followee_count"`
		Followed        bool        `json:"followed"`
		LatestArticle   interface{} `json:"latest_article"`
		IsSubscribed    bool        `json:"is_subscribed"`
		IsPush          bool        `json:"is_push"`
	} `json:"author"`
	Publisher   interface{} `json:"publisher"`
	Readability struct {
		ArticleUnderFreeTrial      bool          `json:"article_under_free_trial"`
		UserHasValidPromotionShare bool          `json:"user_has_valid_promotion_share"`
		UserHasOneValidPrivilege   bool          `json:"user_has_one_valid_privilege"`
		IsFullyReadable            bool          `json:"is_fully_readable"`
		ArticlePrivileges          []interface{} `json:"article_privileges"`
	} `json:"readability"`
	IsCollected          bool          `json:"is_collected"`
	Attachments          []interface{} `json:"attachments"`
	CommentCount         int           `json:"comment_count"`
	IsNewDay             bool          `json:"isNewDay,omitempty"`
	DayTime              string        `json:"dayTime,omitempty"`
	Week                 string        `json:"week,omitempty"`
	IsShowImgs           bool          `json:"isShowImgs,omitempty"`
	DefaultUris          []string      `json:"defaultUris"`
	CompareTime          time.Time     `json:"compare_time"`
	TweetTemplateOpenZh  string        `json:"tweet_template_open_zh,omitempty"`
	TweetTemplateCloseZh string        `json:"tweet_template_close_zh,omitempty"`
}

func (p *UnifiedWisburgPost) GetDedupId() (string, error) {
	dedupId, err := utils.TextToMd5Hash(fmt.Sprintf("%s%d", collector.WisburgSourceId, p.ID))
	if err != nil {
		return "", err
	}
	return dedupId, nil
}

func (p *UnifiedWisburgPost) GetExternalId(channelType protocol.WisburgParams_ChannelType) string {
	return strconv.Itoa(p.ID)
}

func (p *UnifiedWisburgPost) GetContent(channelType protocol.WisburgParams_ChannelType) string {
	if channelType == protocol.WisburgParams_CHANNEL_TYPE_VIEWPOINT {
		return p.TweetTemplate
	}
	if channelType == protocol.WisburgParams_CHANNEL_TYPE_RESEARCH {
		return p.BodySummary
	}
	return ""
}

func (p *UnifiedWisburgPost) GetTitle(channelType protocol.WisburgParams_ChannelType) string {
	if channelType == protocol.WisburgParams_CHANNEL_TYPE_VIEWPOINT || channelType == protocol.WisburgParams_CHANNEL_TYPE_RESEARCH {
		return p.Title
	}
	return ""
}

func (p *UnifiedWisburgPost) GetGeneratedTime() *timestamppb.Timestamp {
	return ParseWisburgLexicalTime(p.DisplayTime)
}

func (p *UnifiedWisburgPost) GetOriginUrl() string {
	return p.URI
}

func (p *UnifiedWisburgPost) GetImageUrls() []string {
	return p.CoverSlideUris
}

type WisburgViewpointApiResponse struct {
	Content struct {
		Viewpoints struct {
			List   []UnifiedWisburgPost `json:"list"`
			Anchor string               `json:"anchor"`
			Count  int                  `json:"count"`
		} `json:"viewpoints"`
	}
}

type WisburgResearchApiResponse struct {
	Content struct {
		ResearchList struct {
			List   []UnifiedWisburgPost `json:"list"`
			Anchor string               `json:"anchor"`
			Count  int                  `json:"count"`
		} `json:"researchList"`
	} `json:"content"`
}

type WisburgCrawler struct {
	Sink sink.CollectedDataSink
}

func (w WisburgCrawler) GetStartUrl(channelType protocol.WisburgParams_ChannelType) string {
	switch channelType {
	case protocol.WisburgParams_CHANNEL_TYPE_VIEWPOINT:
		return "https://wisburg.com/viewpoint"
	case protocol.WisburgParams_CHANNEL_TYPE_RESEARCH:
		return "https://wisburg.com/research"
	default:
		return ""
	}
}

// Wisburg time is very unstandard, it contains:
// 1. 刚刚
// 2. XX分钟前
// 3. XX:XX (北京时间)
// 4. XX/XX XX:XX (北京时间)
func ParseWisburgLexicalTime(s string) *timestamppb.Timestamp {
	if strings.Contains(s, "刚刚") {
		return timestamppb.Now()
	}

	if strings.Contains(s, "分钟") {
		now := time.Now()
		delta, err := strconv.Atoi(s[0:2])
		if err != nil {
			Logger.Log.Errorln("fail to parse Wisburg time", s)
			return timestamppb.Now()
		}
		now.Add(-time.Duration(delta) * time.Minute)
		return timestamppb.New(now)
	}

	if ok, _ := regexp.MatchString("([0-9]+):([0-9]+)", s); ok && len(s) == 5 {
		location, err := time.LoadLocation(ChinaTimeZone)
		if err != nil {
			Logger.Log.Errorln("fail to parse Wisburg time", s)
			return timestamppb.Now()
		}
		year, month, day := time.Now().In(location).Date()
		formatedTimeString := fmt.Sprintf("%d-%d-%d %s:%s:00", year, month, day, s[0:2], s[3:5])

		t, err := time.ParseInLocation(WisburgTimeFormat, formatedTimeString, location)
		if err != nil {
			Logger.Log.Errorln("fail to parse Wisburg time", s)
			return timestamppb.Now()
		}
		return timestamppb.New(t)
	}

	if ok, _ := regexp.MatchString("([0-9]+)\\/([0-9]+) ([0-9]+):([0-9]+)", s); ok && len(s) == 11 {
		location, err := time.LoadLocation(ChinaTimeZone)
		if err != nil {
			Logger.Log.Errorln("fail to parse Wisburg time", s)
			return timestamppb.Now()
		}
		year, _, _ := time.Now().In(location).Date()
		formatedTimeString := fmt.Sprintf("%d-%s-%s %s:%s:00", year, s[0:2], s[3:5], s[6:8], s[9:11])

		t, err := time.ParseInLocation(WisburgTimeFormat, formatedTimeString, location)
		if err != nil {
			Logger.Log.Errorln("fail to parse Wisburg time", s)
			return timestamppb.Now()
		}
		return timestamppb.New(t)
	}

	return timestamppb.Now()
}

func (w WisburgCrawler) GetResponseInJson(channelType protocol.WisburgParams_ChannelType,
	task *protocol.PanopticTask) (string, error) {
	httpClient := collector.NewHttpClientFromTaskParams(task)
	res, err := httpClient.Get(w.GetStartUrl(channelType))
	if err != nil {
		return "", err
	}

	// Load the HTML document
	doc, err := goquery.NewDocumentFromReader(res.Body)
	if err != nil {
		return "", err
	}

	// Wisburg's 3rd <script> tag contains all data we need.
	jsCodeText := doc.Find("script").Eq(3).Text()
	body := strings.Split(
		strings.Split(
			jsCodeText,
			"window.__INITIAL_STATE__=")[1],
		";(function")[0]
	return body, nil
}

func (w WisburgCrawler) GetViewpointStruct(
	channelType protocol.WisburgParams_ChannelType,
	task *protocol.PanopticTask) (*WisburgViewpointApiResponse, error) {
	body, err := w.GetResponseInJson(channelType, task)
	if err != nil {
		return nil, err
	}

	viewpointResponse := &WisburgViewpointApiResponse{}
	err = json.Unmarshal([]byte(body), viewpointResponse)
	if err != nil {
		Logger.Log.Errorf("fail to parse response: %s, type: %T", body, viewpointResponse)
		return nil, err
	}
	return viewpointResponse, nil
}

func (w WisburgCrawler) GetResearchStruct(
	channelType protocol.WisburgParams_ChannelType,
	task *protocol.PanopticTask) (*WisburgResearchApiResponse, error) {
	body, err := w.GetResponseInJson(channelType, task)
	if err != nil {
		return nil, err
	}

	researchResponse := &WisburgResearchApiResponse{}
	err = json.Unmarshal([]byte(body), researchResponse)
	if err != nil {
		Logger.Log.Errorf("fail to parse response: %s, type: %T", body, researchResponse)
		return nil, err
	}
	return researchResponse, nil
}

func (w WisburgCrawler) ProcessViewPoint(
	channelType protocol.WisburgParams_ChannelType,
	task *protocol.PanopticTask) error {
	res, err := w.GetViewpointStruct(channelType, task)
	if err != nil {
		return err
	}

	for _, post := range res.Content.Viewpoints.List {
		workingContext := &working_context.ApiCollectorWorkingContext{
			SharedContext: working_context.SharedContext{Task: task, IntentionallySkipped: false},
			ApiUrl:        w.GetStartUrl(channelType),
		}

		err := w.ProcessUnifiedWisburgPost(channelType, &post, workingContext)
		if err != nil {
			Logger.Log.WithFields(logrus.Fields{"source": "wisburg"}).Errorln("fail to process a single Wisburg Viewpoint Post:", err,
				"\npost content:\n", collector.PrettyPrint(post))
			workingContext.Task.TaskMetadata.TotalMessageFailed++
			continue
		}

		// Returning nil in ProcessSinglePost doesn't necessarily mean success, it
		// could just be that we're skiping that post (e.g. subsource type doesn't
		// match)
		if workingContext.Result != nil {
			sink.PushResultToSinkAndRecordInTaskMetadata(w.Sink, workingContext)
		}
	}

	return nil
}

func (w WisburgCrawler) ProcessResearch(
	channelType protocol.WisburgParams_ChannelType,
	task *protocol.PanopticTask) error {
	res, err := w.GetResearchStruct(channelType, task)
	if err != nil {
		return err
	}

	for _, post := range res.Content.ResearchList.List {
		workingContext := &working_context.ApiCollectorWorkingContext{
			SharedContext: working_context.SharedContext{Task: task, IntentionallySkipped: false},
			ApiUrl:        w.GetStartUrl(channelType),
		}

		err := w.ProcessUnifiedWisburgPost(channelType, &post, workingContext)
		if err != nil {
			Logger.Log.WithFields(logrus.Fields{"source": "wisburg"}).Errorln("fail to process a single Wisburg Research Post:", err,
				"\npost content:\n", collector.PrettyPrint(post))
			workingContext.Task.TaskMetadata.TotalMessageFailed++
			continue
		}

		// Returning nil in ProcessSinglePost doesn't necessarily mean success, it
		// could just be that we're skiping that post (e.g. subsource type doesn't
		// match)
		if workingContext.Result != nil {
			sink.PushResultToSinkAndRecordInTaskMetadata(w.Sink, workingContext)
		}
	}

	return nil
}

// ======= The main logic for processing the post =======
func (w WisburgCrawler) ProcessUnifiedWisburgPost(
	channelType protocol.WisburgParams_ChannelType,
	post *UnifiedWisburgPost,
	workingContext *working_context.ApiCollectorWorkingContext) error {
	collector.InitializeApiCollectorResult(workingContext)

	dedupId, err := post.GetDedupId()
	if err != nil {
		return fmt.Errorf("fail to get dedup id: %w", err)
	}

	workingContext.Result.Post.DeduplicateId = dedupId
	workingContext.Result.Post.Content = post.GetContent(channelType)
	workingContext.Result.Post.ContentGeneratedAt = post.GetGeneratedTime()
	workingContext.Result.Post.Title = post.GetTitle(channelType)
	workingContext.Result.Post.OriginUrl = post.GetOriginUrl()
	workingContext.Result.Post.ImageUrls = post.GetImageUrls()
	if channelType == protocol.WisburgParams_CHANNEL_TYPE_VIEWPOINT {
		workingContext.Result.Post.SubSource.Name = "观点"
	} else if channelType == protocol.WisburgParams_CHANNEL_TYPE_RESEARCH {
		workingContext.Result.Post.SubSource.Name = "研究"
	}
	workingContext.Result.Post.SubSource.AvatarUrl = collector.GetSourceLogoUrl(
		workingContext.Task.TaskParams.SourceId)

	return nil
}

func (w WisburgCrawler) CollectSingleSubSource(channelType protocol.WisburgParams_ChannelType, task *protocol.PanopticTask) error {
	switch channelType {
	case protocol.WisburgParams_CHANNEL_TYPE_VIEWPOINT:
		return w.ProcessViewPoint(channelType, task)
	case protocol.WisburgParams_CHANNEL_TYPE_RESEARCH:
		return w.ProcessResearch(channelType, task)
	default:
		return errors.New("unimplemented channel type")
	}
}

func (w WisburgCrawler) CollectAndPublish(task *protocol.PanopticTask) {
	if len(task.TaskParams.GetWisburgTaskParams().ChannelType) == 0 {
		Logger.Log.Error("No channel type specified for Wisburg")
		return
	}

	for _, t := range task.TaskParams.GetWisburgTaskParams().ChannelType {
		err := w.CollectSingleSubSource(t, task)
		if err != nil {
			Logger.Log.Errorf("fail to crawl a single Wisburg source %s, error: %s", t, err)
			task.TaskMetadata.ResultState = protocol.TaskMetadata_STATE_FAILURE
		}
	}
}
